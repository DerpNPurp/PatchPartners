/*
 * DesignPath's primary purpose is to be an embroidery-sensitive wrapper 
 * around Paper.js' path object.
 * Note that Paper.js' path is made up of "segments" rather than points.
 * However, Path's can be initialized with lists of Paper.js points
 * 
 * DesignPath is primarily a container to be edited by Design.
 * However, DesignPath does handle translating its paperPath to a sewing path
 * -- Does it really though? Not successfully
 * 
 * HOW TO ACCESS/SELECT A PATH VIA "params"
 * params={
 * 	path: {sewn: false/true/"both"}
 *  simplifiedPath: {sewn: false/true/"both"}
 *  flattenedPath: {sewn: false/true/"both"}
 *  generatedPath: {sewn: false/true/"both"}
 * }
 * 
 */

// Set special variable attached to paper.js Path that we will make use of
// Basically, any path of points, in whatever state, can be sewn. 
// DesignPath is what has the knowledge to calculate this path.
// THIS SHOULD BE ANOTHER PATH
paper.Path.prototype.sewnPath = null;
paper.Path.prototype.parentDesign = null;
paper.Path.prototype.parentDesignPath = null;

///////////////////////////////////////////////////////////
/////// It is hard to see the properties of the drawing aspects
//////// So these functions report the object and string versions
////////////////////////////////////////////////////////////////////

paper.Path.prototype.reportDisplay = function(){
	var result = {
		strokeColor: this.strokeColor,
		opacity: this.opacity,
		visible: this.visible,
		selected: this.selected
	};
	return result;
};

paper.Path.prototype.reportDisplayString = function(separator){
	var resultDisplay = this.reportDisplay();
	var result = "";
	for (var key in resultDisplay) {
	    // skip loop if the property is from prototype
	    if (!resultDisplay.hasOwnProperty(key)) continue;
	
		if(separator === undefined || separator === null){
	    	result += key + ": " + resultDisplay[key] + "\n";
	   	} else {
	   		result += key + ": " + resultDisplay[key] + separator;
	   	}
    }
    return result;
};

// I am tired of examining paths for their points so here we go
paper.Path.prototype.stringifyPoints = function(separator){
	console.log(this);
	var result = "";
	result += "[" + this.segments.length + "]: ";
		
	for(var i = 0; i < this.segments.length; i++){
		if(separator === undefined || separator === null){
			result += "(" + this.segments[i].point.x + ", " + this.segments[i].point.y + ")" + " ";
		} else {
			result += "(" + this.segments[i].point.x + ", " + this.segments.points[i].y + ")" + separator;
		}
	}
	
	return result;
};

///////////////////////////////////////////////////////////////////////////////
//////////// DESIGN PATH CONSTRUCTOR //////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

var DesignPath = function(parentDesign, pPath){
	if (parentDesign == undefined || parentDesign == null){
		//console.log("PROBLEMMMMM!!! DESIGN PATH HAS NO PARENT DESIGN!");
		console.log("DesignPath has no parent design, assuming it is for final canvas printing")
		
	} else {
		this.parentDesign = parentDesign;
	}
	
	if (pPath == undefined || pPath == null){
		this.paperPath = new Path();
	} else { 
		// should this be this.paperPath = new Path(pPath)?
		this.paperPath = pPath;
	}
	
	this.derivitivePaths = {
		simplifiedPath: null, // this.paperPath.simplify()
		flattenedPath: null, // this.paperPath.flatten()
		generatedPath: null // generated by our AI later down the file
	};
	// If derivitive paths are dirty, ie the paperPath has been changed
	// We need to know to regenerate stuff
	// We also need to know when it's safe to regenerate the generated path
	this.dirtyPaths = {
		simplifiedPath: true,
		flattenedPath: true,
		generatedPath: true
	};
	
	// Save them drawing styles for the paper.js canvas
	this.lastDisplaySettings = {
		path:						{opacity: 0.5},//, visible: true, selected: true},
		"path.sewnPath": 			{opacity: 1},//, visible: true, selected: true},
		simplifiedPath: 			{opacity: 0.5},//, visible: true, selected: true},strokeColor: 'blue', 
		"simplifiedPath.sewnPath": 	{opacity: 1},//, visible: true, selected: true},
		flattenedPath: 				{opacity: 0.5},//, visible: true, selected: true},
		"flattenedPath.sewnPath":	{opacity: 1},//, visible: true, selected: true},
		generatedPath: 				{opacity: 0.5},//, visible: true, selected: true},
		"generatedPath.sewnPath":	{opacity: 1}//, visible: true, selected: true}
	};
	
	this.allParsedParamOptions = [	"path", "path.sewnPath", 
									"simplifiedPath", "simplifiedPath.sewnPath",
									"flattenedPath", "flattenedPath.sewnPath",
									"generatedPath", "generatedPath.sewnPath"];
									
	// should always be a completely valid set of settings declared here or in parseGenerationParameters
	this.lastGenerationSettings = {
		generateSeedPath: "path",
		type: "sketchNoise"
	};
	
	// Tolerance, Flatness, other properties used in the creation of new lines
	this.lastUsedLineParams = {};
	
	this.active = true;
	
	this.stitchLengthMM = 2;
	this.pixelsPerMM = 10;
	// this is a MAX length. any uneven length is distributed between the ceiling of the division
	this.stitchLengthPixels = undefined;
	console.log("Setting default sewn stitch length");
	this.setSewnStitchLength(this.stitchLengthMM, this.pixelsPerMM);
	
	return this;
}; // DesignPath

/////////////////////////////////////////////////////////
//// GETTERS /////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

// to alleviate copyPaste, this function does all the null and undefined checks
DesignPath.prototype.parseParams = function(params){
	var results = [];
	//console.log("Parsing params", params);
	//console.log("COME ON FLATTENEDPATH", params.flattenedPath);
	if(params === undefined || params === null){
		console.log("parseParams() called with undefined or null params", params);
		return results;
	}
	
	if(params.path !== undefined && params.path !== null){
		//console.log("Parsing params <path>", params.path);
		if(params.path.sewn === undefined || params.path.sewn === null || params.path.sewn === false){
			results.push("path");
		} else if (params.path.sewn === true){
			results.push("path.sewnPath");
		} else if (params.path.sewn === "both"){
			results.push("path");
			results.push("path.sewnPath");
		}
	}
	
	if(params.simplifiedPath !== undefined && params.simplifiedPath !== null){
		//console.log("Parsing params <simplifiedPath>", params.simplifiedPath);
		if(params.simplifiedPath.sewn === undefined || params.simplifiedPath.sewn === null || params.simplifiedPath.sewn === false){
			results.push("simplifiedPath");
		} else if (params.simplifiedPath.sewn === true){
			results.push("simplifiedPath.sewnPath");
		} else if (params.simplifiedPath.sewn === "both"){
			results.push("simplifiedPath");
			results.push("simplifiedPath.sewnPath");
		}
	}
	
	if(params.flattenedPath !== undefined && params.flattenedPath !== null){
		//console.log("Parsing params <flattenedPath>", params.flattenedPath);
		if(params.flattenedPath.sewn === undefined || params.flattenedPath.sewn === null || params.flattenedPath.sewn === false){
			results.push("flattenedPath");
		} else if (params.flattenedPath.sewn === true){
			results.push("flattenedPath.sewnPath");
		} else if (params.flattenedPath.sewn === "both"){
			results.push("flattenedPath");
			results.push("flattenedPath.sewnPath");
		}
	}
	
	if(params.generatedPath !== undefined && params.generatedPath !== null){
		//console.log("Parsing params <generatedPath>", params.generatedPath);
		if(params.generatedPath.sewn === undefined || params.generatedPath.sewn === null || params.generatedPath.sewn === false){
			results.push("generatedPath");
		} else if (params.generatedPath.sewn === true){
			results.push("generatedPath.sewnPath");
		} else if (params.generatedPath.sewn === "both"){
			results.push("generatedPath");
			results.push("generatedPath.sewnPath");
		}
	}
	
	//console.log("parsed params RESULTS: ", results);
	return results;
};

// Can only grab 1 set of generated params.
// WILL RETURN ONLY THE FIRST ONE
// should be a list of 1 length from this.parseParams
DesignPath.prototype.getLastDisplayParamsForParsedParams = function(parsedParams){
	if(parsedParams !== undefined && parsedParams !== null && parsedParams.length > 0){
		if(parsedParams.length > 1){
			console.log("getLastDisplayParamsForParsedParams only returning first of parsedParams", parsedParams);
		}
		return this.lastDisplaySettings[parsedParams[0]];
	} else {
		throw new Error("Cannot getLastDisplayParamsForParsedParams with invalid parsedParams", parsedParams);
		return null;
	}
};

 /* HOW TO ACCESS/SELECT A PATH VIA "params"
 * params={
 * 	path: {sewn: false/true}
 *  simplifiedPath: {sewn: false/true}
 *  flattenedPath: {sewn: false/true}
 * }
 */
// getPaperPath returns the first applicable path
// TODO -- regenerates paths if they are dirty
// -- regenerates sewn paths if they are non-null of a dirty path
DesignPath.prototype.getPaperPath = function(params){
	if(params === undefined || params === null){
		console.log("getPath params undefined/null, returning null", params);
		return null;
	}
	var parsedParams = this.parseParams(params);
	if(parsedParams.length > 1) console.log("getPaperPath will only return 1 path at a time, returning path at 0", parsedParams);
	
	// skips if length is 0
	for(var i = 0; i < parseParams.length; i++){
	
		switch(parseParams[i]) {
		    case "path":
		        return this.paperPath;
		        break;
		    case "path.sewnPath":
		        return this.paperPath.sewnPath;
		        break;
		    case "simplifiedPath":
		        return this.derivitivePaths.simplifiedPath;
		        break;
		    case "simplifiedPath.sewnPath":
		        return this.derivitivePaths.simplifiedPath.sewnPath;
		        break;
		    case "flattenedPath":
		        return this.derivitivePaths.flattenedPath;
		        break;
		    case "flattenedPath.sewnPath":
		        return this.derivitivePaths.flattenedPath.sewnPath;
		        break;
		    case "generatedPath":
		        return this.derivitivePaths.generatedPath;
		        break;
		    case "generatedPath.sewnPath":
		        return this.derivitivePaths.generatedPath.sewnPath;
		        break;
		    default:
		    	console.log("No case for parse params", this.parseParams[i]);
		        break;
		}
	}
	
	console.log("no acceptable path key specified in getPaperPath params, returning null", params);
	return null;
}; // getPaperPath


// Params: path is null or paper.js path
// Pre: this.stithLengthPixels is set by this.setSewnStitchLength
// Return: A NEW PAPER.JS PATH made off the x,y coordinates calculated
// NOTE: Because this path could be any of the paths here, we do not know what drawing settings it should have
// THIS FUNCTION IS JUST WRONG/UNTESTED
// TODO: FIX THIS or hand to math off once we know hoop size
DesignPath.prototype.calcSewnPath = function(path){
	if(path == null){
		throw new Error("Cannot getSewnPath for a null path, even paperPath", path);
		return;
	}
	if(path.length <= 1){
		throw new Error("Cannot getSewnPath for a path of <= 1 pixel distance", path);
		return;
	}
	if(path.segments.length <= 1){
		throw new Error("Cannot getSewnPath for a path of 0 or 1 segments", path);
		return;
	}
	
	console.log("...calcSewnPath...");
	console.log(path.stringifyPoints());
	
	var plottedPoints = [];
	console.log("plotting", path);
	console.log("Path length // this.stitchLengthPixels", path.length, this.stitchLengthPixels);
	var numPoints = Math.ceil(path.length/this.stitchLengthPixels); // Makes sure all is <= stitchLengthPixels
	console.log("fits # of points (without endpoint)", numPoints);

	// loops for numPoints+1 for the endpoint, which should be at offset = path.length (i and numPoints cancel each other out)
	for(var i = 0; i <= numPoints; i++){
		var offset = (path.length/numPoints) * i;
		var point = path.getPointAt(offset);
		console.log("Plotted point 1 by offset", i, offset, point);
		plottedPoints.push(point);
	}

	
	var newPath = new Path(plottedPoints);
	console.log("...POST calcSewnPath...");
	console.log(newPath.stringifyPoints());
	return newPath;
};

///////////////////////////////////////////////////////////////////
//////////// SETTERS //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

// Accepts new path from active drawing. Need to redraw all now-dirty paths
DesignPath.prototype.acceptNewJSPath = function(path){
	this.paperPath = path;
	this.paperPath.dashArray = [2, 4];
	this.setAllPathsDirty();
};

// Sets the flags that all paths should be re-generated
// Should be called when this.paperPath is changed
DesignPath.prototype.setAllPathsDirty = function(){
	for (var key in this.dirtyPaths) {
	    // skip loop if the property is from prototype
	    if (!this.dirtyPaths.hasOwnProperty(key)) continue;
	
	    this.dirtyPaths[key] = true;
    }
	return this.dirtyPaths;
};

// tolerance, flatness, etc.
DesignPath.prototype.setLastUsedLineParams = function(params){
	if(params === undefined || params === null){
		console.log("Calling setLastUsedLineParams with invalid params, doing nothing", params);
		return;
	}
	
	for (var key in params) {
	    // skip loop if the property is from prototype
	    if (!params.hasOwnProperty(key)) continue;
	
	    this.lastUsedLineParams[key] = params[key];
    }
    return this.lastUsedLineParams;
};

// Args: None
// Pre: None
// Post: Non-null paths are set as hidden
DesignPath.prototype.setAllPathsHidden = function(){
	if(this.paperPath !== null){
		//console.log("setting path invisible paperPath");
		this.paperPath.visible = false;
		if(this.paperPath.sewnPath !== undefined && this.paperPath.sewnPath !== null){
			this.paperPath.sewnPath.visible = false;
		}
	}
	for (var key in this.derivitivePaths) {
	    // skip loop if the property is from prototype
	    if (!this.derivitivePaths.hasOwnProperty(key)) continue;
	
	    if (this.derivitivePaths[key] !== null){
	    	//console.log("setting derivitive path invisible", key);
	    	this.derivitivePaths[key].visible = false;
	    	if(this.derivitivePaths[key].sewnPath !== undefined && this.derivitivePaths[key].sewnPath !== null){
	    		this.derivitivePaths[key].sewnPath.visible = false;
	    	}
	    	
	    } 
    }
	
};

// Args: None
// Pre: None
// Post: Non-null paths are set as not selected
DesignPath.prototype.setAllPathsDeselected = function(){
	if(this.paperPath !== null){
		//console.log("setting path deselected paperPath");
		this.paperPath.selected = false;
		if(this.paperPath.sewnPath !== undefined && this.paperPath.sewnPath !== null){
			this.paperPath.sewnPath.selected = false;
		}
	}
	
	for (var key in this.derivitivePaths) {
	    // skip loop if the property is from prototype
	    if (!this.derivitivePaths.hasOwnProperty(key)) continue;
	
	    if (this.derivitivePaths[key] !== null){
	    	//console.log("setting derivitive path deselected", key);
	    	this.derivitivePaths[key].selected = false;
	    	if(this.derivitivePaths[key].sewnPath !== undefined && this.derivitivePaths[key].sewnPath !== null){
	    		this.derivitivePaths[key].sewnPath.selected = false;
	    	}
	    } 
    }
};

// TODO: save what the old visible/selected settings were

DesignPath.prototype.deactivate = function(){
	// TODO: save last settings
	// THIS IS TAKING A LONG TIME AND HURTING MY HEAD
	// And do we even need it? Eh, not now!
	
	// set all to visible = false and selected = false
	this.active = false;
	//this.setAllPathsDeselected();
	//this.setAllPathsHidden();
	if(this.paperPath !== null){
		this.paperPath.visible = false;
	}
	if(this.derivitivePaths.generatedPath !== null){
		this.derivitivePaths.generatedPath.visible = false;
	}
};

// TODO: make a load function that uses those settings 
DesignPath.prototype.reactivate = function(){
	// load last settings
	this.active = true;
	// in place of loading last settings, let's just set stuff to visible
	if(this.paperPath !== null){
		this.paperPath.visible = true;
	}
	if(this.derivitivePaths.generatedPath !== null){
		this.derivitivePaths.generatedPath.visible = true;
	}
	
};

/* HOW TO ACCESS/SELECT A PATH VIA "params"
 * params={
 * 	path: {sewn: false/true}
 *  simplifiedPath: {sewn: false/true}
 *  flattenedPath: {sewn: false/true}
 * }
 */
// NOTE: This can select and show multiple paths!!
// NOTE: THIS REFRESHES DRAWING PARAMS!
DesignPath.prototype.selectAndShowPaths = function(params){
	if(params === undefined || params === null){
		// Uhh? What do we want default behavior to be?
		console.log("Cannot selectAndShowPaths without params", params);
		return;
	}
	//console.log("*****flattenedPath", this.derivitivePaths.flattenedPath.reportDisplay());
	var parsedParams = this.parseParams(params);
	//console.log("*********selecting and showing in generatedPath.js", params, parsedParams);
	// skips if length is 0
	for(var i = 0; i < parsedParams.length; i++){
		//console.log("WHAT IS MY CASE?", parsedParams[i])
		var param = parsedParams[i];
		//console.log("*************Setting " + param + " visible");
		var paramPath = null;
		
		switch(parsedParams[i]) {
		    case "path":
		    	if(this.paperPath !== null){
		    		this.paperPath.selected = true;
					this.paperPath.visible = true;
					paramPath = this.paperPath;
				}
		        break;
		    case "path.sewnPath":
		    	if(this.paperPath !== null && this.paperPath.sewnPath !== null){
			        this.paperPath.sewnPath.selected = true;
					this.paperPath.sewnPath.visible = true;
					paramPath = this.paperPath.sewnPath;
				}
		        break;
		    case "simplifiedPath":
		    	if(this.derivitivePaths.simplifiedPath !== null){
			        this.derivitivePaths.simplifiedPath.selected = true;
					this.derivitivePaths.simplifiedPath.visible = true;
					paramPath = this.derivitivePaths.simplifiedPath;
				}
		        break;
		    case "simplifiedPath.sewnPath":
		    	if(this.derivitivePaths.simplifiedPath !== null && this.derivitivePaths.simplifiedPath.sewnPath !== null){
			        this.derivitivePaths.simplifiedPath.sewnPath.selected = true;
			        this.derivitivePaths.simplifiedPath.sewnPath.visible = true;
			        paramPath = this.derivitivePaths.simplifiedPath.sewnPath;
		    	}
		        break;
		    case "flattenedPath":
		        if(this.derivitivePaths.flattenedPath !== null){
		        	this.derivitivePaths.flattenedPath.selected = true;
					this.derivitivePaths.flattenedPath.visible = true;
					paramPath = this.derivitivePaths.flattenedPath;
				}
		        break;
		    case "flattenedPath.sewnPath":
		        if(this.derivitivePaths.flattenedPath !== null && this.derivitivePaths.flattenedPath.sewnPath !== null){
					this.derivitivePaths.flattenedPath.sewnPath.selected = true;
		        	this.derivitivePaths.flattenedPath.sewnPath.visible = true;
		        	paramPath = this.derivitivePaths.flattenedPath.sewnPath;
		        }
		        break;
		    case "generatedPath":
		        if(this.derivitivePaths.generatedPath !== null){
					this.derivitivePaths.generatedPath.selected = true;
					this.derivitivePaths.generatedPath.visible = true;
					paramPath = this.derivitivePaths.generatedPath;
		        }
		        break;
		    case "generatedPath.sewnPath":
		        if(this.derivitivePaths.generatedPath !== null && this.derivitivePaths.generatedPath.sewnPath !== null){
					this.derivitivePaths.generatedPath.sewnPath.selected = true;
			        this.derivitivePaths.generatedPath.sewnPath.visible = true;
			        paramPath = this.derivitivePaths.generatedPath.sewnPath;
		        }
		        break;
		    default:
		    	console.log("No case for parse params", this.parseParams[i]);
		        break;
		}
				
		//console.log(paramPath.reportDisplayString());
	}
	
	// None is selected, so we show everything and select nothing
	if(parsedParams.length == 0){
		//console.log("SettingPathDrawingProperties to all visible & selected false");
		this.setPathDrawingProperties({
			"path": {visible: true, selected:false},
			"path.sewnPath": {visible: true, selected:false},
			"simplifiedPath": {visible: true, selected:false},
			"simplifiedPath.sewnPath": {visible: true, selected:false},
			"flattenedPath": {visible: true, selected:false},
			"flattenedPath.sewnPath": {visible: true, selected:false},
			"generatedPath": {visible: true, selected:false},
			"generatedPath.sewnPath": {visible: true, selected:false},
		});
	}
	
	//console.log("flattenedPath VISIBLE?!", this.derivitivePaths.flattenedPath);
	// If we have shown ANYTHING, we should make sure it has the most up-to-date drawing properties
	// -> moving this earlier to save the visibility settings BEFORE applying them
    // so we don't just save them all being invisible...
	this.applyPathDrawingProperties();
	
	//console.log("flattenedPath DRAWN WELL?", this.derivitivePaths.flattenedPath);
	
	return;
};

// Format:
// {parsedPathKey: {strokeColor: "color", opacity: float}} // plus any other valid path properties
// Not NECESSARY because we set default settings...
// TODO: TEST
DesignPath.prototype.setPathDrawingProperties = function(params){
	if(params === undefined || params === null){
		console.log("Cannot setPathDrawingProperties without params", params);
		return;
	}
	//console.log("setPathDrawingProperties", params);
	for (var key in params) {
	    // skip loop if the property is from prototype
	    if (!params.hasOwnProperty(key)) continue;
	    //console.log("setting params[key]", key, params[key]);
	
		// params[key] == parsedPath string
	    if (params[key] !== null){
	    	for(var doubleKey in params[key]){
	    		//console.log("--- double key within params[key]", doubleKey);
	    		
	    		if (!params[key].hasOwnProperty(doubleKey)) continue;
	    		
	    		//console.log("setting params[key][doubleKey]", params[key], doubleKey);
	    		// lastDisplaySettings[params[key]][doubleKey] is the lastDisplaySettings for stroke, etc.
	    		// params[key][doubleKey] is the "strokeColor" etc. from the params
	    		// THIS WORKS BECAUSE ALL THE params[key] ARE THE SAME STRINGS AS parsedParams
	    		if(params[key][doubleKey] !== null){
	    			this.lastDisplaySettings[key][doubleKey] = params[key][doubleKey];
	    		}
	    	
	    	}
	    } 
    }
    // If we have changed the drawing properties in our settings,
    // Make sure to apply them to all the actual lines

    this.applyPathDrawingProperties();
    return;
	
};

// Goes through all last drawing properties and sets them for every path...
// Pre: this.lastDisplaySettings[parsedParams] has some values
// IF YOU DO NOT WANT DEFAULT SETTINGS, CALL this.setPathDrawingProperties FIRST
DesignPath.prototype.applyPathDrawingProperties = function(){
	//console.log("Setting pathDrawingProperties...");
	//console.log("THIS LAST DISPLAY SETTINGS: ", this.lastDisplaySettings);
	if(this.paperPath !== null){
		for (var key in this.lastDisplaySettings.path) {
		    // skip loop if the property is from prototype
		    if (!this.lastDisplaySettings.path.hasOwnProperty(key)) continue;
		    //console.log("setting path", key, this.lastDisplaySettings.path[key]);
		    this.paperPath[key] = this.lastDisplaySettings.path[key];
		}
		// sewnPath version
		if(this.paperPath.sewnPath !== undefined && this.paperPath.sewnPath !== null){
			for (var key2 in this.lastDisplaySettings["path.sewnPath"]) {
			    // skip loop if the property is from prototype
			    if (!this.lastDisplaySettings["path.sewnPath"].hasOwnProperty(key2)) continue;
			    //console.log("setting path.paperPath", key2, this.lastDisplaySettings["path.sewnPath"]);
			    this.paperPath.sewnPath[key2] = this.lastDisplaySettings["path.sewnPath"][key2];
			}
		}
		//console.log("check paperPath properties", this.paperPath);
	}
	//console.log("Applying all stuff to <this.derivitivePaths>", this.derivitivePaths);
	for (var pathKey in this.derivitivePaths) {
	    // skip loop if the property is from prototype
	    if (!this.derivitivePaths.hasOwnProperty(pathKey)) continue;
	    //console.log("processing <pathKey> of <derivitivePath>", pathKey, this.derivitivePaths[pathKey]); // should be simplified/flattened/generated
	    
	    if(this.derivitivePaths[pathKey] !== undefined && this.derivitivePaths[pathKey] !== null){
	    	// for each drawing property for this path key...
	    	// Process NON-SEWNPATH VERSION
		    for (var key in this.lastDisplaySettings[pathKey]) {
			    // skip loop if the property is from prototype
			    if (!this.lastDisplaySettings[pathKey].hasOwnProperty(key)) continue;
			    //console.log("<key> of <pathkey> <DISPLAY SETTINGS", key, pathKey, this.lastDisplaySettings[pathKey]);
			    this.derivitivePaths[pathKey][key] = this.lastDisplaySettings[pathKey][key];
				//console.log("check <derivitivePath>", this.derivitivePaths[pathKey]);
			}
			// Process SEWNPATH VERSION
			if(this.derivitivePaths[pathKey].sewnPath !== undefined && this.derivitivePaths[pathKey].sewnPath !== null){
				//console.log("processing derivitivePaths <pathKey>'s <sewnpath>'", pathKey, this.derivitivePaths[pathKey].sewnPath);
			
				for (var key in this.lastDisplaySettings[pathKey + ".sewnPath"]) {
				    // skip loop if the property is from prototype
				    if (!this.lastDisplaySettings[pathKey + ".sewnPath"].hasOwnProperty(key)) continue;
				    //console.log("setting <key> of display settings <pathkey.sewnPath>", key, this.lastDisplaySettings[pathKey + ".sewnPath"]);
				    this.derivitivePaths[pathKey].sewnPath[key] = this.lastDisplaySettings[pathKey + ".sewnPath"][key];
					//console.log("check <derivitivePaths.sewnPath>", this.derivitivePaths[pathKey].sewnPath.reportDisplayString(" | "));
				}
			}
		}
	    
	}
	
	return;
	
};

// stitchLength is in mm
// pixelsPerMM is the screen -> stitchLength scale conversion
// pixelsPerMM should always be a number >1 (otherwise jesus how tiny is this path/screen? Oh, but that's an idea....)
DesignPath.prototype.setSewnStitchLength = function(stitchLengthMM, pixelsPerMM){
	this.stitchLengthMM = stitchLengthMM;
	this.pixelsPerMM = pixelsPerMM;

	this.stitchLengthPixels = stitchLengthMM * pixelsPerMM; 

	//console.log("Stitch Length Properties Set: " + this.stitchLengthMM + " * " + this.pixelsPerMM + " = " + this.stitchLengthPixels);
};

// Args: path is a paper.js path
// Pre: none
// Post: this.paperPath is set to the path
//       all derivitive paths are marked as dirty
/* NO BAD BAD BAD BAD .remove() takes it out of the canvas. If this is the same parent path, it's removed, gone poof!
DesignPath.prototype.setNewPaperPath = function(path){
	if(path == null){
		console.log("setting a null path in setNewPaperPath?", path);
	}
	// Clean up old path
	if(this.paperPath !== null) {
		this.paperPath.remove();
	}
	// set new path
	this.paperPath = path;
	
	console.log("setNewPaperPath!", path);
	// set dirty
	this.setAllPathsDirty();
}; */

// Args: path: non-null paper.js path
// Pre: this.paperPath !== null
// Post: this.generatedPath is set to path
DesignPath.prototype.setDesignPath = function(path){
	if(path == null){
		console.log("setDesignPath cannot be set with null path", path);
		return;
	}
	
	if(this.paperPath == null){
		console.log("Should not be setDesignPath on a null paperpath");
	}
	
	// Clean up old path
	if(this.derivitivePaths.generatedPath !== null) {
		this.derivitivePaths.generatedPath.remove();
	}
	
	this.derivitivePaths.generatedPath = path;
	this.dirtyPaths.generatedPath = false;
	
};

////////////////////////////////////////////////////////////////
///// OPERATIONS ///////////////////////////////////////////////
////////////////////////////////////////////////////////////////

// Args: a non-null paper.js path // TODO: CHECK or make new case for list of points []
// Pre: None
// Post: returns new path with locations in path as whole numbers
DesignPath.prototype.roundPathPoints = function(path){
	if(path == undefined || path == null){
		console.log("Cannot roundPathPoints without a paper.js path", path);
	}
	console.log("...Pre-rounded path...");
	console.log(path.stringifyPoints());
	var newPath = path.clone();
	for(var i = 0; i < path.segments.length; i++){
		var newPoint = path.segments[i].point.clone();
		newPoint.x = Math.round(newPoint.x);
		newPoint.y = Math.round(newPoint.y);
		newPath.add(newPoint);
	}
	
	console.log("...POST-rounded path...");
	console.log(newPath.stringifyPoints());
	
	return newPath;
};

// CALCULATE SIZE?

// MOVE DESIGN?

// FIND CENTER?

/////////////////////////////////////////////////////////////////
///// COMPUTE PATHS ////////////////////////////////////////////
////////////////////////////////////////////////////////////////

// Pre: this.paperPath !== null, as it is the source of all paths
//			OR params.path !== undefined && !== null
// Post: If any of the follow paths are !== null, regenerate their points:
//			this.paperPath.sewnPath 
//			this.derivitivePaths.simplifiedPath
//			this.derivitivePaths.simplifiedPath.sewnPath
//			this.derivitivePaths.flattenedPath
//			this.derivitivePaths.flattenedPath.sewnPath
//			this.derivitivePaths.generatedPath
//			this.derivitivePaths.generatedPath.sewnPath
DesignPath.prototype.regenerateAllPaths = function(params){
	//console.log("RegenerateAllPaths", params);
	if(params !== undefined && params !== null){
		if(params.stitchLength !== undefined && params.stitchLength !== null){
			this.setSewnStitchLength(params.stitchLength, this.pixelsPerMM);
		}
		
		
		if(params.path !== undefined && params.path !== null){
			//This is bad, this.setNewPaperPath(params.path); .removes the old path
			//console.log("setNewPaperPath", params.path);
			//this.setNewPaperPath(params.path);
			this.acceptNewJSPath(params.path);
			
		}
	}
	// TODO: Make sewing paths work
	//this.generatePaperPathSewnPath();
	
	////////////////////
	// DEPRICATED -- Used for old view options
	// Currently useless for the user to understand
	// and soaks up unnecessary computing power
	////////////////////
	//this.generateSimplifiedPath(params);
	//this.generateFlattenedPath(params);
	//
	this.generatePath(params);
	
};

DesignPath.prototype.generatePaperPathSewnPath = function(){
	if(this.paperPath == undefined || this.paperPath == null){
		throw new Error("Cannot generatePaperPathSewnPath off of an invalid paperPath", this.paperPath);
		return;
	}
	// If this.paperPath should have a sewn path, 
	if(this.paperPath.sewnPath !== undefined && this.paperPath.sewnPath !== null){
		this.paperPath.sewnPath.remove();
		this.paperPath.sewnPath = null;
	}
	// This just produces garbage, skip for now (TODO FIX THIS)
	//this.paperPath.sewnPath = this.roundPathPoints(this.calcSewnPath(this.paperPath));
	this.paperPath.sewnPath = this.roundPathPoints(this.paperPath);
	return this.paperPath.sewnPath;
};

// Returns a list of points for this.derivitivePaths.generatedPath
// Held in this.derivitivePaths.generatedPath.sewnPath
DesignPath.prototype.generateGeneratedSewnPath = function(){
	if(this.derivitivePaths.generatedPath == undefined || this.derivitivePaths.generatedPath == null){
		throw new Error("Cannot generateGeneratedSewnPath off of an invalid path", this.derivitivePaths.generatedPath);
		return;
	}
	// If this.paperPath should have a sewn path, 
	if(this.derivitivePaths.generatedPath.sewnPath !== undefined && this.derivitivePaths.generatedPath.sewnPath !== null){
		this.derivitivePaths.generatedPath.sewnPath.remove();
		this.derivitivePaths.generatedPath.sewnPath = null;
	}
	// This just produces garbage, skip for now (TODO FIX THIS)
	//this.derivitivePaths.generatedPath.sewnPath = this.roundPathPoints(this.calcSewnPath(this.derivitivePaths.generatedPath));
	this.derivitivePaths.generatedPath.sewnPath = this.derivitivePaths.generatedPath;
	return this.derivitivePaths.generatedPath.sewnPath;
};

// Pre: this.paperPath is not null, otherwise return 
// Post: this.derivitivePaths.simplifiedPath is set if this.paperPath is not null
//       this.derivitivePaths.simplifiedPath.sewn is recalculated if it was not null
//       this.dirtyPaths.simplifiedPath = false
DesignPath.prototype.generateSimplifiedPath = function(params){
	// Check dependencies
	if(this.paperPath === null){
		throw new Error("Should not be calling generateSimplifiedPath without a paperPath");
		return;
	}
	
	// clean up old, dirty path
	if(this.derivitivePaths.simplifiedPath !== null){
		if(this.derivitivePaths.simplifiedPath.sewnPath !== null){
			this.derivitivePaths.simplifiedPath.sewnPath.remove();
			this.derivitivePaths.simplifiedPath.sewnPath = null;
		}
		this.derivitivePaths.simplifiedPath.remove();
		this.derivitivePaths.simplifiedPath = null;
	}
	
	// GENERATE IT
	this.derivitivePaths.simplifiedPath = this.paperPath.clone();
	
	if(params === undefined || params.tolerance === undefined){
		if(this.lastUsedLineParams !== undefined && 
			this.lastUsedLineParams !== null &&
			this.lastUsedLineParams.tolerance !== undefined){
			this.derivitivePaths.simplifiedPath.simplify(this.lastUsedLineParams.tolerance);
		} else {
			console.log("using default path settings in generateSimplifidPath", params);
			// Part of Paper.js
			this.derivitivePaths.simplifiedPath.simplify();
		}
	} else {
		this.setLastUsedLineParams(params);
		this.derivitivePaths.simplifiedPath.simplify(params.tolerance);
	}
	
	// regenerate sewn path too
	// this.roundPathPoints returns a new Path
	// BROKEN, needs fixing
	//this.derivitivePaths.simplifiedPath.sewnPath = this.roundPathPoints(this.calcSewnPath(this.derivitivePaths.simplifiedPath));
	
	
	// FLAG IS NOW CLEAN
	this.dirtyPaths.simplifediPath = false;
};

// Pre: paperPath is not null, otherwise return 
//      simplifiedPath !== null or dirty, otherwise generate it
// Post: this.derivitivePaths.flattenedPath is set if this.paperPath is not null
//       this.derivitivePaths.flattenedPath.sewn is recalculated if it was not null
//       this.dirtyPaths.flattenedPath = false

DesignPath.prototype.generateFlattenedPath = function(params){
	// Check dependencies
	if(this.paperPath === null){
		throw new Error("Should not be calling generateFlattenedPath without a paperPath");
		return;
	}
	
	if(this.derivitivePaths.simplifiedPath === null ||
		this.dirtyPaths.simplifiedPath == true){
		console.log("generateFlattenedPath with a null or dirty simplifiedPath, regenerate that first");
		this.generateSimplifiedPath(params);
		// How did that go? Did it succeed? We still need that path to not be null...
		if(this.derivitivePaths.simplifiedPath === null){
			throw new Error("BAD BAD simplifiedPath is failing to be made, GTFO", this.derivitivePaths);
			return;
		}
		
	}
	// clean up old, dirty path
	if(this.derivitivePaths.flattenedPath !== null){
		if(this.derivitivePaths.flattenedPath.sewnPath !== null){
			this.derivitivePaths.flattenedPath.sewnPath.remove();
			this.derivitivePaths.flattenedPath.sewnPath = null;
		}
		this.derivitivePaths.flattenedPath.remove();
		this.derivitivePaths.flattenedPath = null;
	}
	
	// GENERATE IT
	this.derivitivePaths.flattenedPath = this.derivitivePaths.simplifiedPath.clone();
	
	if(params === undefined || params.flatness === undefined){
		if(this.lastUsedLineParams !== undefined && 
			this.lastUsedLineParams !== null &&
			this.lastUsedLineParams.flatness !== undefined){
			this.derivitivePaths.flattenedPath.flatten(this.lastUsedLineParams.flatness);
		} else {
			console.log("using default path settings in generateFlattenedPath");
			//  Part of Paper.js
			this.derivitivePaths.flattenedPath.flatten(); // default is 2.5, it is the maximum error allowed
		}
	} else {
		this.setLastUsedLineParams(params);
		this.derivitivePaths.flattenedPath.flatten(params.flatness);
	}
	// regenerate sewn path
	// BROKEN Needs fixing
	//this.derivitivePaths.flattenedPath.sewnPath = this.roundPathPoints(this.calcSewnPath(this.derivitivePaths.flattenedPath));
	
	
	// FLAG IS NOW CLEAN
	this.dirtyPaths.flattnedPath = false;
};

// Pre: params has something in it
// Post: Returns a new params with valid settings for designGenerator.js,
//		mainly dealing with grabbing the right paths using reference names from design.js
DesignPath.prototype.parseGenerationParameters = function(params){
	var newParams = {};
	
	if(params === undefined || params == null){
		//console.log("parsingGenerationParameters has no parameters to parse. Use last saved version", this.lastGenerationSettings);
		params = this.lastGenerationSettings;
	} 
	/////////// PATH ////////////
	if (params.generateSeedPath === undefined || params.generateSeedPath === null) {

		//console.log("called parseGenerationParameters with invalid parameters: must include a generateSeedPath", params);
		//console.log("parseGenerationParameters using last saved version", this.lastGenerationSettings);
		params.generateSeedPath = this.lastGenerationSettings.generateSeedPath;
	} 
	
	//console.log("parseGenerationParameters parsing ", params.generateSeedPath);
	switch(params.generateSeedPath) {
	    case "path":
	        newParams.path = this.paperPath;
	        break;
	    case "path.sewnPath":
	        newParams.path = this.paperPath.sewnPath;
	        break;
	    case "simplifiedPath":
	        newParams.path = this.derivitivePaths.simplifiedPath;
	        break;
	    case "simplifiedPath.sewnPath":
	        newParams.path = this.derivitivePaths.simplifiedPath.sewnPath;
	        break;
	    case "flattenedPath":
	        newParams.path = this.derivitivePaths.flattenedPath;
	        console.log("Should be saving flattenedPath", this.derivitivePaths);
	        break;
	    case "flattenedPath.sewnPath":
	        newParams.path = this.derivitivePaths.flattenedPath.sewnPath;
	        break;
	    case "generatedPath":
	        console.log("Currently not supporting recursive generated paths");
	        break;
	    case "generatedPath.sewnPath":
	        console.log("Currently not supporting recursive generated paths");
	        break;
	    default:
	    	console.log("No case for parsing params.generateSeedPath", params);
	        break;
	}
	
	
	if(newParams.path === undefined || newParams.path === null){
		throw new Error("FAILED TO PARSE A PATH from given params or last settings. BAD BAD BAD!!!", params, this.lastGenerationSettings, newParams);
		return null;
	}
	
	/////////// GENERATION TYPE ///////////
	if (params.type === undefined || params.type === null) {

		//console.log("called parseGenerationParameters with invalid parameters: should include a type", params);
		//console.log("parseGenerationParameters using last saved type", this.lastGenerationSettings);
		console.log("WE SHOULD NOT BE USING UNDEFINED PARAM TYPES ANYMORE!!!");
		params.type = this.lastGenerationSettings.type;
	} 
	newParams.type = params.type;
	///////////////////////////////////////
	
	/////TODO: GENERATION VARIABLES ///////
	
	///////////////////////////////////////
	
	//console.log("Successfully parsed a new path params! Hurrah!", newParams);
	return newParams;

};

// Pre: paperPath is not null, otherwise return 
//      
// Post: this.derivitivePaths.generatedPath is set if this.paperPath is not null
//       this.derivitivePaths.generatedPath.sewn is recalculated if it was not null
//       this.dirtyPaths.generatedPath = false

DesignPath.prototype.generatePath = function(params){
	// Check dependencies
	if(this.paperPath === null){
		throw new Error("Should not be calling generatePath without a paperPath");
		return;
	}
	

	// clean up old, dirty path
	if(this.derivitivePaths.generatedPath !== null){
		if(this.derivitivePaths.generatedPath.sewnPath !== null){
			this.derivitivePaths.generatedPath.sewnPath.remove();
			this.derivitivePaths.generatedPath.sewnPath = null;
		}
		this.derivitivePaths.generatedPath.remove();
		this.derivitivePaths.generatedPath = null;
	}
	
	var parsedParams = this.parseGenerationParameters(params);
	
	// GENERATE IT
	this.derivitivePaths.generatedPath = global.mainDesignGenerator.generate(parsedParams);
	this.derivitivePaths.generatedPath.dashArray = [4,0];
	
	//console.log("Generated path", this.derivitivePaths.generatedPath);
	// When we have the params nailed, make sure to check/save them
	/*
	if(params === undefined || params.flatness === undefined){
		if(this.lastUsedLineParams !== undefined && 
			this.lastUsedLineParams !== null &&
			this.lastUsedLineParams.flatness !== undefined){
			this.derivitivePaths.flattenedPath.flatten(this.lastUsedLineParams.flatness);
		} else {
			console.log("using default path settings in generateFlattenedPath");
			//  Part of Paper.js
			this.derivitivePaths.flattenedPath.flatten(); // default is 2.5, it is the maximum error allowed
		}
	} else {
		this.setLastUsedLineParams(params);
		this.derivitivePaths.flattenedPath.flatten(params.flatness);
	}
	*/
	// regenerate sewn path
	// TODO: Make sewing paths work
	//this.derivitivePaths.generatedPath.sewnPath = this.roundPathPoints(this.calcSewnPath(this.derivitivePaths.generatedPath));
	
	
	// FLAG IS NOW CLEAN
	this.dirtyPaths.generatedPath = false;
};

DesignPath.prototype.toJSON = function() {
    return {
		paperPath: this.paperPath ? JSON.parse(this.paperPath.exportJSON()) : null, 
		simplifediPath: this.derivitivePaths.simplifediPath ? JSON.parse(this.derivitivePaths.simplifediPath.exportJSON()) : null, 
		flattenedPath: this.derivitivePaths.flattenedPath ? JSON.parse(this.derivitivePaths.flattenedPath.exportJSON()) : null, 
		generatedPath: this.derivitivePaths.generatedPath ? JSON.parse(this.derivitivePaths.generatedPath.exportJSON()) : null, 
        // paperPath: this.paperPath ? this.paperPath.exportJSON() : null,
        type: this.type,
        stitchLengthMM: this.stitchLengthMM,
        pixelsPerMM: this.pixelsPerMM,
        lastUsedLineParams: this.lastUsedLineParams,
        lastDisplaySettings: this.lastDisplaySettings,
        active: this.active,
    };
};


DesignPath.prototype.scale = function(scale) {

	if (this.paperPath !== null) {
		this.paperPath.scale(scale, new Point(0, 0));
	}

	if (this.derivitivePaths.simplifiedPath !== null) {
		this.derivitivePaths.simplifiedPath.scale(scale, new Point(0, 0));
    }

    if (this.derivitivePaths.flattenedPath !== null) {
		this.derivitivePaths.flattenedPath.scale(scale, new Point(0, 0));
    }

    if (this.derivitivePaths.generatedPath !== null) {
		this.derivitivePaths.generatedPath.scale(scale, new Point(0, 0));
    }

    this.setAllPathsDirty();
};

